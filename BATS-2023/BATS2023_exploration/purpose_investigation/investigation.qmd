---
title: "Quarto Basics"
format:
  html:
    code-fold: true
jupyter: python3
---

For a demonstration of a line plot on a polar axis, see @fig-polar.

```{python}
#| label: setup

import numpy as np
from pathlib import Path
import polars as pl
from linker import LinkerTinker
import plotly.express as px
import plotly.graph_objects as go
from scipy.stats import gaussian_kde

# Not really sure where everything should live but all this is pretty sinful
DATA_DIR = Path("E:\\Box\\Modeling and Surveys\\Surveys\\Travel Diary Survey")
DATA_DIR = DATA_DIR / "BATS_2023\\MTC_RSG_Partner Repository\\5.Deliverables"
DATA_DIR = DATA_DIR / "Task 10 - Weighting and Expansion Data Files"
DATA_DIR = DATA_DIR / "WeightedDataset_12112024"
TRIP_PATH = DATA_DIR / "trip.csv"

# Hardcoded codes
CHANGE_MODE_CODE: int = 11  # Purpose code for 'change_mode'
TRANSIT_MODES: list[str] = [12, 13, 14]

 # Mode Mapping for readability
MODE_TYPE_MAP = {
    1: "Walk",
    2: "Bike",
    3: "Bikeshare",
    4: "Scootershare",
    5: "Taxi",
    6: "TNC",
    7: "Other",
    8: "Car",
    9: "Carshare",
    10: "School bus",
    11: "Shuttle/vanpool",
    12: "Ferry",
    13: "Transit",
    14: "Long distance passenger",
    995: "Missing Response",
}

PURPOSE_MAP = {
    -1: "Not imputable",
    1: "Home",
    2: "Work",
    3: "Work related",
    4: "School",
    5: "School related",
    6: "Escort",
    7: "Shop",
    8: "Meal",
    9: "Social or recreational",
    10: "Errand",
    11: "Change mode",
    12: "Overnight",
    13: "Other",
}

EMPLOY_MAP = {
    1: "Employed full-time (paid)",
    2: "Employed part-time (paid)",
    3: "Self-employed",
    5: "Not employed and not looking for work (e.g., retired, stay-at-home parent, student)",
    6: "Unemployed and looking for work",
    7: "Unpaid volunteer or intern",
    8: "Employed, but not currently working (e.g., on leave, furloughed 100%)",
    995: "Missing Response",    
}

```

```{python}
#| label: Link'em

# Load data
trips_df = pl.read_csv(TRIP_PATH)
persons_df = pl.read_csv(DATA_DIR / "person.csv")
days_df = pl.read_csv(DATA_DIR / "day.csv")

# Much wow RSG...
trips_df = trips_df.rename({"arrive_second": "arrive_seconds"})

# Instantiate BATS Handler
BATS = LinkerTinker(
    trips_df,
    change_mode_code=CHANGE_MODE_CODE,
    transit_mode_codes=TRANSIT_MODES,
)

# Link the trips
BATS.link_trips()

# Get linked trips dataframe
linked_trips_df = BATS.linked_trips

```

```{python}

# Join employment status to linked trips
employment_linked_trips = linked_trips_df.join(
    persons_df.select(["person_id", "employment"]),
    on="person_id",
    how="left",
)

# Calculate total weighted and unweighted days by employment status
employment_day_totals = (
    days_df
    .join(
        persons_df.select(["person_id", "employment", "hh_id"]),
        on=["person_id", "hh_id"],
        how="left",
    )
    .group_by("employment").agg([
        pl.len().alias("unweighted_days"),
        pl.col("day_weight").sum().alias("weighted_days"),
    ])
    .with_columns(
        pl.col("employment").cast(pl.Utf8).replace(EMPLOY_MAP).alias("employment_status"),
    )
    .sort("unweighted_days", descending=True)
    .drop("employment")
)

# Calculate total work and work-related trips by employment status
employment_work_trips = (
    employment_linked_trips
    .filter(
        pl.col("d_purpose_category").is_in([2,3]) &
        (pl.col("linked_trip_weight") > 0), # Drop incomplete trips
    )
    .group_by("employment").agg([
        pl.len().alias("unweighted_work_trips"),
        pl.col("linked_trip_weight").sum().alias("weighted_work_trips"),
    ])
    .with_columns(
        pl.col("employment").cast(pl.Utf8).replace(EMPLOY_MAP).alias("employment_status"),
    )
    .sort("unweighted_work_trips", descending=True)
)

# Merge and calculate trip rates
employment_summary = (
    employment_day_totals
    # Join work trips
    .join(
        employment_work_trips,
        on="employment_status",
        how="left",
    )
)

# Add total row
total_row = pl.DataFrame({
    "employment": [0],
    "employment_status": ["Total"],
    "unweighted_days": [employment_summary["unweighted_days"].sum()],
    "weighted_days": [employment_summary["weighted_days"].sum()],
    "unweighted_work_trips": [employment_summary["unweighted_work_trips"].sum()],
    "weighted_work_trips": [employment_summary["weighted_work_trips"].sum()],
}).cast(employment_summary.schema)

employment_summary = pl.concat([employment_summary, total_row], how="diagonal")

# Calculate trip rates
employment_summary = (
    employment_summary
    .with_columns([
        (pl.col("unweighted_work_trips") / pl.col("unweighted_days"))
        .alias("unweighted_trip_rate"),
        (pl.col("weighted_work_trips") / pl.col("weighted_days"))
        .alias("weighted_trip_rate"),
    ])
)

# Just display Employed and Self-employed
employment_summary = employment_summary.filter(
    pl.col("employment").is_in([1,2,3])
)

# Bar chart of trip rates by employment status
fig = px.bar(
    employment_summary
    .filter(pl.col("employment_status") != "Total")
    .to_pandas(),
    x="employment_status",
    y=["unweighted_trip_rate", "weighted_trip_rate"],
    barmode="group",
    labels={
        "employment_status": "Employment Status",
        "value": "Trip Rate (Trips per Day)",
        "variable": "",
    },
    title="Weekday Work Trip Rates by Employment Status",
)
fig.update_traces(texttemplate="%{y:.2f}", textposition="outside")
fig.show()
```


```{python}
#| label: school-trips
#| fig-cap: "School trips by mode"

# Get school trips by mode -------
school_mode = (
    linked_trips_df
    .filter(
        pl.col("d_purpose_category").is_in([3,4]) &
        (pl.col("linked_trip_weight") > 0), # Drop incomplete trips
        )
    .group_by("mode_type").agg([
        pl.len().alias("count"),
        pl.col("linked_trip_weight").sum().alias("weighted_count"),
    ])
    .with_columns(
        pl.col("mode_type").cast(pl.Utf8).replace(MODE_TYPE_MAP).alias("mode"),
    )
    .sort("count", descending=True)
    .drop("mode_type")
    .with_columns([
        (pl.col("count") / pl.col("count").sum() * 100).alias("share"),
        (pl.col("weighted_count") / pl.col("weighted_count").sum() * 100)
        .alias("weighted_share"),
    ])
)

# Reshape for plotting
school_mode_long = school_mode.unpivot(
    index=["mode", "count", "weighted_count"],
    on=["share", "weighted_share"],
    variable_name="type",
    value_name="percentage",
).with_columns([
    pl.when(pl.col("type") == "share")
        .then(pl.col("count"))
        .otherwise(pl.col("weighted_count").round(0).cast(pl.Int32))
        .alias("text_value"),
    pl.col("type")
    .replace({"share": "Unweighted", "weighted_share": "Weighted"}),
])

# Interative plotly plot
fig = px.bar(
    school_mode_long,
    x="mode",
    y="percentage",
    color="type",
    barmode="group",
    labels={"mode": "Mode Type", "percentage": "Share (%)", "type": ""},
    text="text_value",
    title="School Trips by Mode",
)
fig.update_traces(texttemplate="%{text:.3~s}", textposition="outside")
fig.show()
```

```{python}
#| label: overnights
#| fig-cap: "Overnight Trips"

# Filter overnight trips
overnights = linked_trips_df.filter(pl.col("d_purpose_category") == 12)
overnights_complete = overnights.filter(
    pl.col('linked_trip_weight') > 0
)

# Summary statistics
share_with_weight = 100 * overnights_complete.shape[0] / overnights.shape[0]

print(f"Total overnight trips recorded: {overnights.shape[0]:,}")
print(f"Total overnight trips with weight > 0: {overnights_complete.shape[0]:,}")
print(f"Share of overnight trips with weight > 0: {share_with_weight:.2f}%")
```

```{python}

# Select daily diaries for 10 random overnight-flagged days
overnight_days = (
    overnights_complete
    .select("day_id")
    .unique()
    .sample(n=10, with_replacement=False, seed=42)
    .to_series()
    .to_list()
)

overnight_diaries = (
    # Filter overnight days
    linked_trips_df
    .filter(
        pl.col("day_id").is_in(overnight_days)
    )
    # Select relevant columns and map for readability
    .select(
        [
            "linked_trip_id",
            "day_id",
            "depart_time",
            "arrive_time",
            "d_purpose_category",
            "mode_type",
            "linked_trip_weight",
        ]
    )
    # Map codes to strings
    .with_columns([
        pl.col("mode_type").cast(pl.Utf8).replace(MODE_TYPE_MAP).alias("mode"),
        pl.col("d_purpose_category").cast(pl.Utf8).replace(PURPOSE_MAP).alias("purpose"),
        pl.col("day_id").cast(pl.Utf8).alias("day_id"),
    ])
    .sort("depart_time")
    # Normalize date time to a common date for plotting
    .with_columns([
        pl.col("depart_time").dt.replace(year=2024, month=1, day=1).alias("depart_time"),
        pl.col("arrive_time").dt.replace(year=2024, month=1, day=1).alias("arrive_time"),
    ])
)


# Create color map with overnight highlighted
# Use a muted color palette for non-overnight purposes
muted_colors = px.colors.qualitative.Pastel + px.colors.qualitative.Set3
color_map = {
    purpose: muted_colors[i % len(muted_colors)] 
    for i, purpose in enumerate(PURPOSE_MAP.values())
}
color_map["Overnight"] = "red"  # Make overnight stand out

fig = px.timeline(
    overnight_diaries.to_pandas(),
    x_start="depart_time",
    x_end="arrive_time",
    y="day_id",
    color="purpose",
    color_discrete_map=color_map,
    hover_data=["mode"],
    title="Trips for 10 Day IDs with Overnight Trips",
)
fig.update_yaxes(title="Day ID")
fig.update_xaxes(title="Time of Day")
fig.show()

```


```{python}
#| label: depart-time
#| fig-cap: "Weighted Departure Time Density (Ignoring Date)"

# --- Convert to hour of day (float) ---
linked_trips_df = linked_trips_df.with_columns([
    (pl.col("depart_time").dt.hour() + pl.col("depart_time").dt.minute() / 60)
    .alias("depart_hour_float"),
])

# Plot weighted distribution of departure times for all weighted trips as gut check
fig = px.histogram(
    linked_trips_df.to_pandas(),
    x="depart_hour_float",
    nbins=48,
    histfunc="sum",
    y="linked_trip_weight",
    title="Weighted Departure Time Distribution",
    labels={
        "depart_hour_float": "Hour of Day",
        "linked_trip_weight": "Weighted Count",
    },
)

fig.update_layout(
    xaxis=dict(
        tickmode="array",
        tickvals=list(range(0, 25, 3)),
        ticktext=[f"{h:02d}:00" for h in range(0, 25, 3)]
    )
)
fig.show()
```

```{python}
#| label: depart-overnights
#| fig-cap: "Departure Times for Overnight Trips"
# Plot departure times for overnight trips
# Add arrival hour column
overnight_departures = linked_trips_df.filter(
    (pl.col("d_purpose_category") == 12) & (pl.col("linked_trip_weight") > 0)
).with_columns([
    (pl.col("arrive_time").dt.hour() + pl.col("arrive_time").dt.minute() / 60)
    .alias("arrive_hour_float"),
])

# Create figure with overlaid histograms
fig = go.Figure()

fig.add_trace(go.Histogram(
    x=overnight_departures["depart_hour_float"],
    y=overnight_departures["linked_trip_weight"],
    histfunc="sum",
    nbinsx=24,
    name="Departure",
    opacity=0.7,
))

fig.add_trace(go.Histogram(
    x=overnight_departures["arrive_hour_float"],
    y=overnight_departures["linked_trip_weight"],
    histfunc="sum",
    nbinsx=24,
    name="Arrival",
    opacity=0.7,
))

fig.update_layout(
    title="Departure and Arrival Times for Overnight Trips",
    xaxis_title="Hour of Day",
    yaxis_title="Weighted Count",
    barmode="overlay",
    xaxis=dict(
        tickmode="array",
        tickvals=list(range(0, 25, 3)),
        ticktext=[f"{h:02d}:00" for h in range(0, 25, 3)]
    )
)

fig.show()
```